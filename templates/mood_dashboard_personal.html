{% extends "base.html" %}

{% block title %}My Mood Tracker - FAMJAM{% endblock %}

{% block content %}
<div class="space-y-8">
  <div class="text-center">
    <h1 class="text-4xl font-bold text-gray-900 dark:text-gray-100">Mood Tracker ðŸ˜ŠðŸ˜ŸðŸ˜ </h1> {# Added emojis #}
    <p class="text-lg text-gray-600 dark:text-gray-300 mt-2">
      Hi, {{ current_user.username }}! Log how you're feeling throughout the day.
    </p>
  </div>

  {# Mood Logging Grid #}
  <div class="bg-white dark:bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-xl hover-lift">
    <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4"> {# Added gap #}
      <h3 class="text-2xl font-bold text-gray-900 dark:text-gray-100 flex items-center flex-wrap"> {# Added flex-wrap #}
        Log Your Mood for
        {# Date input styling #}
        <input type="date" id="mood-date" class="bg-gray-100 dark:bg-gray-700 rounded-lg p-2 ml-2 border border-gray-300 dark:border-gray-600 focus:ring-blue-500 focus:border-blue-500 transition">
      </h3>
      {# Link to Family View - only show if user is parent? Or always show? Assuming always show for now. #}
       {% if current_user.role == 'parent' %}
       <a href="{{ url_for('mood_dashboard_family') }}"
          class="flex-shrink-0 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-full hover:bg-blue-700 transition focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-blue-500">
         View Family Moods
       </a>
       {% endif %}
    </div>
    {# Mood grid container - populated by JS #}
    <div id="mood-grid" class="grid grid-cols-1 md:grid-cols-3 gap-6">
        {# Cells generated by JS #}
        <div class="text-center py-10 text-gray-500 dark:text-gray-400 md:col-span-3">Loading mood logger...</div>
    </div>
  </div>

  {# Mood History Chart #}
  <div class="bg-white dark:bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-xl hover-lift">
    <h3 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">My Mood History (Last 30 Days)</h3>
    <div class="h-80 relative"> {# Added relative #}
      <canvas id="personalMoodChart"></canvas>
    </div>
  </div>

  {# AI Consultation Card #}
  <div class="bg-white dark:bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-xl hover-lift text-center">
    <h3 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Need some perspective? ðŸ¤”</h3> {# Added emoji #}
    <p class="text-gray-600 dark:text-gray-300 mb-6 max-w-2xl mx-auto leading-relaxed"> {# Added leading #}
      Get supportive, AI-powered insights based on your mood history to better understand your emotional patterns.
    </p>
    <button id="consult-ai-btn"
            class="px-6 py-3 font-semibold text-white bg-secondary-500 rounded-lg
                   hover:bg-secondary-600 transition-transform transform hover:scale-105 shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-secondary-500 dark:focus:ring-offset-gray-800">
      Consult AI for Insights
    </button>
  </div>
</div>

{# AI Insights Modal #}
<div id="ai-modal"
     class="fixed inset-0 bg-gray-900 bg-opacity-60 dark:bg-black dark:bg-opacity-80 z-[80] hidden flex items-center justify-center p-4 backdrop-blur-sm"> {# Added backdrop blur #}
  <div class="relative p-6 border w-full max-w-2xl shadow-2xl rounded-2xl bg-white dark:bg-gray-800 dark:text-gray-100 modal-content" style="max-height: 90vh;"> {# Added max-height #}
    <button onclick="closeModal('ai-modal')"
            class="absolute top-4 right-4 text-gray-400 dark:text-gray-300 hover:text-gray-600 dark:hover:text-gray-200 text-3xl">&times;</button>
    <h3 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">AI-Powered Insights</h3>
    {# Content container with scrolling #}
    <div id="ai-response-content" class="prose-styles max-h-[60vh] overflow-y-auto custom-scrollbar pr-4 text-gray-700 dark:text-gray-200">
      {# AI response loaded here #}
      <p>Loading insights...</p>
    </div>
     <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-right">
       <button onclick="closeModal('ai-modal')" class="px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition">
         Close
       </button>
     </div>
  </div>
</div>
{% endblock %}


{% block scripts %}
{# Page-specific JavaScript for Mood Tracking and AI Consult #}
<script>
document.addEventListener('DOMContentLoaded', () => {
    let personalMoodChart; // Chart instance variable

    const moodGrid = document.getElementById('mood-grid');
    const moodDateInput = document.getElementById('mood-date');
    const consultAIBtn = document.getElementById('consult-ai-btn');
    const aiResponseContent = document.getElementById('ai-response-content');
    const aiModal = document.getElementById('ai-modal');

    // Ensure mood_config is passed correctly from your Flask route
    const MOOD_CONFIG = {{ mood_config.moods | tojson | safe }};
    const PERIODS = ['Morning', 'Afternoon', 'Evening'];
    const formatDate = d => d.toISOString().split('T')[0]; // Simple YYYY-MM-DD format

    if (moodGrid && moodDateInput) {
        // Set initial date to today
        moodDateInput.value = formatDate(new Date());

        const renderMoodGrid = () => {
            if (!moodGrid) return;
            moodGrid.innerHTML = ''; // Clear previous grid
            const chosenDate = moodDateInput.value;

            // --- ADD THIS CHECK ---
            const todayStr = formatDate(new Date());
            const isReadOnly = (chosenDate !== todayStr);
            // --- END ADDED CHECK ---

            PERIODS.forEach(period => {
                const cell = document.createElement('div');
                // --- UPDATE THIS LINE ---
                cell.className = `mood-grid-cell p-4 bg-gray-50 dark:bg-gray-700/60 rounded-lg transition-shadow duration-200 ${isReadOnly ? 'opacity-70' : 'hover:shadow-lg'}`;
                // --- END UPDATE ---
                cell.dataset.period = period;
                
                // --- UPDATE THIS ENTIRE HTML BLOCK ---
                cell.innerHTML = `
                    <h4 class="font-bold text-lg text-center text-gray-800 dark:text-gray-100 mb-4">${period}</h4>
                    <div class="mood-selector grid grid-cols-4 gap-2 ${isReadOnly ? 'pointer-events-none' : ''}">
                        ${MOOD_CONFIG.map(m => `<button data-emoji="${m.emoji}" title="${m.desc}" class="text-3xl p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600 transition transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-blue-400" ${isReadOnly ? 'disabled' : ''}>${m.emoji}</button>`).join('')}
                    </div>
                    <textarea class="mt-4 w-full p-2 bg-white dark:bg-gray-600 rounded-md border border-gray-300 dark:border-gray-500 text-sm focus:ring-blue-500 focus:border-blue-500 transition" rows="2" placeholder="Add a note (optional)..." ${isReadOnly ? 'disabled' : ''}></textarea>
                    <button class="save-mood-btn mt-3 w-full py-2 px-4 text-sm font-semibold text-white bg-blue-500 rounded-lg hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800 ${isReadOnly ? 'hidden' : ''}">Save Mood</button>
                    ${isReadOnly ? '<p class="mt-3 text-xs text-center text-gray-500 dark:text-gray-400">Moods can only be logged for today.</p>' : ''}
                `;
                // --- END UPDATE ---
                
                moodGrid.appendChild(cell);
                fetchMoodForCell(cell, chosenDate, period); // Fetch existing mood for this cell
            });
        };

        const fetchMoodForCell = async (cell, dateStr, period) => {
             // Fetch mood data for a specific cell
             try {
                const response = await fetch(`/api/mood/personal?date=${dateStr}&period=${period}`);
                 if (!response.ok) {
                     // Don't throw error, just means no mood logged yet
                     console.log(`No mood found for ${dateStr} ${period}`);
                     return;
                 }
                const data = await response.json();
                if (data && data.mood_emoji) {
                    const textarea = cell.querySelector('textarea');
                    const selectedButton = cell.querySelector(`button[data-emoji="${data.mood_emoji}"]`);
                    if(textarea) textarea.value = data.note || '';
                    if (selectedButton) {
                        // Mark as selected
                        selectedButton.classList.add('bg-blue-200', 'dark:bg-blue-800', 'ring-2', 'ring-blue-500');
                         // Update Save button text
                         const saveBtn = cell.querySelector('.save-mood-btn');
                         if(saveBtn) saveBtn.textContent = 'Update Mood';
                    }
                }
            } catch (error) {
                console.error(`Error fetching mood for ${dateStr} ${period}:`, error);
            }
        };

        // Event delegation for mood selection and saving
        moodGrid.addEventListener('click', async (e) => {
            const cell = e.target.closest('.mood-grid-cell');
            if (!cell) return;

            // Handle mood emoji button click
            if (e.target.closest('.mood-selector button')) {
                const btn = e.target.closest('.mood-selector button');
                // Deselect others in the same cell
                cell.querySelectorAll('.mood-selector button').forEach(b => b.classList.remove('bg-blue-200', 'dark:bg-blue-800', 'ring-2', 'ring-blue-500'));
                // Select clicked button
                btn.classList.add('bg-blue-200', 'dark:bg-blue-800', 'ring-2', 'ring-blue-500');
                 // Update save button text in case it was 'Saved!'
                 const saveBtn = cell.querySelector('.save-mood-btn');
                 if(saveBtn) saveBtn.textContent = 'Save Mood';
            }

            // Handle save button click
            if (e.target.classList.contains('save-mood-btn')) {
                const saveButton = e.target;
                const selectedEmojiBtn = cell.querySelector('.mood-selector button.bg-blue-200'); // Check for the selected class

                if (!selectedEmojiBtn) {
                    // Simple feedback, could be more elaborate
                    // Replaced alert with a non-blocking feedback
                    saveButton.textContent = 'Please select a mood!';
                    saveButton.classList.add('bg-red-500', 'hover:bg-red-600');
                    setTimeout(() => {
                        saveButton.textContent = 'Save Mood';
                        saveButton.classList.remove('bg-red-500', 'hover:bg-red-600');
                    }, 2000);
                    return;
                }

                saveButton.disabled = true;
                saveButton.textContent = 'Saving...';

                const payload = {
                    date: moodDateInput.value,
                    period: cell.dataset.period,
                    emoji: selectedEmojiBtn.dataset.emoji,
                    note: cell.querySelector('textarea').value.trim()
                };

                try {
                    const response = await fetch('/api/mood/log', { // Ensure this endpoint exists
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                         const errorData = await response.json().catch(() => ({}));
                         throw new Error(errorData.error || `Failed to save mood (Status: ${response.status})`);
                    }
                     saveButton.textContent = 'Saved!';
                     saveButton.classList.replace('bg-blue-500','bg-green-500'); // Indicate success
                     saveButton.classList.replace('hover:bg-blue-600','hover:bg-green-600');
                     await updatePersonalMoodChart(); // Update chart after successful save
                     setTimeout(() => {
                          saveButton.textContent = 'Update Mood'; // Change to Update after save
                          saveButton.classList.replace('bg-green-500','bg-blue-500');
                          saveButton.classList.replace('hover:bg-green-600','hover:bg-blue-600');
                          saveButton.disabled = false;
                     }, 2000);

                } catch (error) {
                    console.error('Failed to save mood:', error);
                    // Replaced alert with non-blocking feedback
                    saveButton.textContent = `Error: ${error.message}`;
                    saveButton.classList.add('bg-red-500', 'hover:bg-red-600');
                    setTimeout(() => {
                         saveButton.textContent = 'Save Mood';
                         saveButton.classList.remove('bg-red-500', 'hover:bg-red-600');
                         saveButton.disabled = false;
                    }, 3000);
                }
            }
        });

        // Update grid when date changes
        moodDateInput.addEventListener('change', renderMoodGrid);

        // Initial render
        renderMoodGrid();

    } // end if moodGrid check

    // --- Personal Mood Chart ---
    const updatePersonalMoodChart = async () => {
         const chartCanvas = document.getElementById('personalMoodChart');
         if (!chartCanvas) return;
         const ctx = chartCanvas.getContext('2d');

         try {
             // --- THIS IS THE FIXED LINE ---
             const response = await fetch('/api/mood/personal'); // Endpoint for chart data
             if (!response.ok) throw new Error('Failed to fetch mood history');
             const data = await response.json();

             if (!data || !data.labels || !data.data) {
                 throw new Error("Mood history data is malformed.");
             }

             if (personalMoodChart) {
                 personalMoodChart.destroy(); // Clear previous chart instance
             }

              const chartTextColor = document.documentElement.classList.contains('dark') ? '#cbd5e1' : '#4b5563';
              const chartGridColor = document.documentElement.classList.contains('dark') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';

             personalMoodChart = new Chart(ctx, {
                 type: 'line',
                 data: {
                     labels: data.labels, // Dates
                     datasets: [{
                         label: 'My Average Daily Mood Score', // Mood score (0-4 typically)
                         data: data.data,
                         borderColor: '#ec4899', // Pink color
                         backgroundColor: 'rgba(236, 72, 153, 0.1)', // Light pink fill
                         tension: 0.3, // Slight curve
                         fill: true,
                         pointBackgroundColor: '#db2777', // Darker pink points
                         pointBorderColor: '#ffffff',
                         pointHoverBackgroundColor: '#ffffff',
                         pointHoverBorderColor: '#be185d',
                         pointRadius: 3,
                         pointHoverRadius: 5
                     }]
                 },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     scales: {
                         y: {
                             beginAtZero: true,
                             max: 4, // Assuming mood score is 0-4
                             ticks: {
                                 stepSize: 1,
                                 // Optional: Map score back to emoji/label
                                 callback: function(value) {
                                      // Find mood config entry matching the score (value)
                                      // Find the closest score
                                      const moodEntry = MOOD_CONFIG.reduce((prev, curr) => {
                                          return (Math.abs(curr.score - value) < Math.abs(prev.score - value) ? curr : prev);
                                      });
                                      // Only show label if it's an exact match to an entry
                                      if (moodEntry.score === value) {
                                          return `${moodEntry.emoji} (${value})`;
                                      }
                                      return value;
                                 },
                                 color: chartTextColor
                             },
                              grid: { color: chartGridColor }
                         },
                         x: {
                              ticks: { color: chartTextColor },
                              grid: { display: false }
                         }
                     },
                      plugins: {
                          legend: { display: false },
                           tooltip: {
                               backgroundColor: document.documentElement.classList.contains('dark') ? '#374151' : '#ffffff',
                               titleColor: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937',
                               bodyColor: document.documentElement.classList.contains('dark') ? '#d1d5db' : '#4b5563',
                               borderColor: document.documentElement.classList.contains('dark') ? '#4b5563' : '#e5e7eb',
                               borderWidth: 1,
                               padding: 10,
                               cornerRadius: 4,
                               // Custom tooltip to show emoji
                               callbacks: {
                                    label: function(context) {
                                         let label = context.dataset.label || '';
                                         if (label) { label += ': '; }
                                         if (context.parsed.y !== null) {
                                              const score = context.parsed.y;
                                              // Find closest mood entry for tooltip
                                              const moodEntry = MOOD_CONFIG.reduce((prev, curr) => {
                                                  return (Math.abs(curr.score - score) < Math.abs(prev.score - score) ? curr : prev);
                                              });
                                              label += moodEntry ? `${moodEntry.emoji} ${moodEntry.desc} (~${score.toFixed(1)})` : score.toFixed(1);
                                         }
                                         return label;
                                    }
                               }
                           }
                      },
                      interaction: { intersect: false, mode: 'index' }
                 }
             });
         } catch (error) {
             console.error("Error updating personal mood chart:", error);
             if (chartCanvas && chartCanvas.parentElement) {
                 chartCanvas.parentElement.innerHTML = '<p class="text-center text-red-500 dark:text-red-400 py-10">Could not load mood history chart.</p>';
             }
         }
    };

    // Initial chart load
    updatePersonalMoodChart();


    // --- AI Consultation ---
    if (consultAIBtn && aiResponseContent && aiModal) {
        consultAIBtn.addEventListener('click', async () => {
            aiResponseContent.innerHTML = `
                <div class="flex justify-center items-center py-8">
                  <svg class="animate-spin h-6 w-6 text-blue-500 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg>
                  <span>Consulting the AI... Please wait.</span>
                </div>`;
            openModal('ai-modal');

            try {
                const response = await fetch('/api/consult-ai', { // Ensure this endpoint exists
                    method: 'POST' // Assuming POST request
                });
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'AI consultation failed.');
                }

                // Use Marked.js if available, otherwise just display text
                if (typeof marked !== 'undefined') {
                    aiResponseContent.innerHTML = marked.parse(data.ai_response || 'No response from AI.');
                } else {
                    // Basic formatting for preformatted text if Marked is not loaded
                    aiResponseContent.innerHTML = `<pre class="whitespace-pre-wrap">${data.ai_response || 'No response from AI.'}</pre>`;
                }

            } catch (error) {
                console.error('AI Consultation Error:', error);
                aiResponseContent.innerHTML = `<p class="text-red-500 dark:text-red-400 p-4">Error: ${error.message}</p>`;
            }
        });
    } // end if consultAIBtn check

}); // End DOMContentLoaded
</script>
{% endblock %}

